<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>스키마 &amp; 타입 | GraphQL</title><meta name="viewport" content="width=640"/><meta property="og:title" content="GraphQL: API를 위한 쿼리 언어"/><meta property="og:description" content="GraphQL은 API에 있는 데이터에 대한 완벽하고 이해하기 쉬운 설명을 제공하고 클라이언트에게 필요한 것을 정확하게 요청할 수 있는 기능을 제공하며 시간이 지남에 따라 API를 쉽게 진화시키고 강력한 개발자 도구를 지원합니다."/><meta property="og:type" content="website"/><meta property="og:url" content="http://graphql-kr.github.io/"/><meta property="og:image" content="/img/og_image.png"/><meta property="og:image:type" content="image/png"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@graphql"/><meta name="twitter:title" content="GraphQL: A query language for APIs."/><meta name="twitter:description" content="GraphQL gives clients the power to ask for exactly what they need and nothing more, making it easier to evolve APIs over time."/><meta name="twitter:image" content="/img/twitter_image.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="home" type="application/rss+xml" href="/blog/rss.xml" title="GraphQL Team Blog"/><link rel="stylesheet" href="/style.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Rubik:300|Roboto:300"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,400i,600"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/></head><body><header><section><a class="nav-home" href="/"><img class="nav-logo" src="/img/logo.svg" width="30" height="30"/>GraphQL</a><nav><a href="/learn/">배우기</a><a href="/code/">코드</a><a href="/community/">커뮤니티</a><a href="/blog/">블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a></nav><div class="algolia-search-wrapper"><input type="text" id="algolia-search-input" placeholder="Search docs..."/></div></section></header><section><div class="documentationContent"><div class="inner-content"><h1>스키마 &amp; 타입</h1><div><p>이 페이지에서는 GraphQL 타입 시스템에 대해 알아야 할 사항과 쿼리 할 수 있는 데이터를 표현하는 방법을 배우게됩니다. GraphQL은 모든 백엔드 프레임워크 또는 프로그래밍 언어와 함께 사용할 수 있기 때문에 구현과 관련된 세부 정보에서 벗어나 개념에 대해서만 이야기 할 것입니다.</p><h3><a class="anchor" name="type-system"></a>Type system <a class="hash-link" href="#type-system">#</a></h3><p>이전에 GraphQL 쿼리를 본 적이 있다면 GraphQL 쿼리 언어가 기본적으로 객체의 필드를 선택하는 것임을 알 수 있습니다. 다음 쿼리 예제를 보세요.</p><p>If you&#x27;ve seen a GraphQL query before, you know that the GraphQL query language is basically about selecting fields on objects. So, for example, in the following query:</p><div id="r101"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><ol><li>특별한 <code>root</code> 객체로 시작합니다.</li><li><code>hero</code> 필드를 선택합니다.</li><li><code>hero</code> 에 의해 반환 된 객체에 대해 <code>name</code> 과 <code>appearIn</code> 필드를 선택합니다</li></ol><p>GraphQL 쿼리의 형태가 결과와 거의 일치하기 때문에 서버에 대해 모르는 상태에서 쿼리가 반환 할 내용을 예측할 수 있습니다. 하지만 서버에 요청할 수 있는 데이터에 대한 정확한 표현을 갖는 것이 유용합니다. 어떤 필드를 선택할 수 있는지, 어떤 종류의 객체를 반환 할 수 있는지, 해당 하위 객체에서 사용할 수 있는 필드는 무엇인지, 이것이 바로 스키마가 필요한 이유입니다.</p><p>모든 GraphQL 서비스는 해당 서비스에서 쿼리 가능한 데이터 집합을 완벽히 설명하는 타입들을 정의합니다. 그런 다음 쿼리가 들어 오면 해당 스키마에 대해 유효성이 검사되고 실행됩니다.</p><h3><a class="anchor" name="type-language"></a>Type language <a class="hash-link" href="#type-language">#</a></h3><p>GraphQL 서비스는 어떤 언어로든 작성할 수 있습니다. GraphQL 스키마에 대해 말하기 전에 JavaScript와 같은 특정 프로그래밍 언어 구문에 의존 할 수 없기 때문에 간단한 언어를 정의 할 것입니다. 여기서는 <code>GraphQL 스키마 언어</code> 를 사용할 것입니다 - 이것은 쿼리 언어와 비슷하며 GraphQL 스키마를 언어에 구애받지 않는 방식으로 표현 할 수 있게 해줍니다.</p><h3><a class="anchor" name="object-types-and-fields"></a>Object types and fields <a class="hash-link" href="#object-types-and-fields">#</a></h3><p>GraphQL 스키마의 가장 기본적인 구성 요소는 객체 타입입니다. 객체 타입은 서비스에서 가져올 수 있는 객체의 종류와 그 객체의 필드를 나타냅니다. GraphQL 스키마 언어에서는 다음과 같이 표현 할 수 있습니다.</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Character <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span><span class="punctuation">!</span>
<span class="punctuation">}</span></span></span></pre><p>이 언어는 꽤 읽을 만하지만, 서로 이해할 수 있도록 이 언어를 살펴 보겠습니다.</p><ul><li><code>Character</code> 는 <em>GraphQL 객체 타입</em>입니다. 즉, 일부 필드가 있는 유형입니다. 스키마의 대부분의 타입은 객체 타입입니다.</li><li><code>name</code> 과 <code>appearIn</code> 은 <code>Character</code> 타입의 <em>필드</em>입니다. 즉 <code>name</code> 과 <code>appearIn</code> 은 <code>Character</code> 타입으로 작동하는 GraphQL 쿼리의 어느 부분에도 나타날 수 있는 유일한 필드입니다.</li><li><code>String</code> 은 내장 된 <em>스칼라</em> 타입 중 하나입니다. 이것은 단일 스칼라 객체로 해석되는 타입이며 쿼리에서 하위 선택을 가질 수 없습니다. 스칼라 타입은 나중에 자세히 다룰 것입니다.</li><li><code>String!</code> 은 필드가 <em>non-nullable</em>임을 의미합니다. 즉, 이 필드를 쿼리 할 때 GraphQL 서비스가 항상 값을 제공한다는 것을 의미합니다. 타입 언어에서는 이것을 느낌표로 나타냅니다.</li><li><code>[Episode]!</code> 는 <code>Episode</code> 객체의 <em>array</em> 를 나타냅니다. 또한 <em>non-nullable</em> 이기 때문에 <code>appearIn</code> 필드를 쿼리할 때 항상(0개 이상의 아이템을 가진) 배열을 기대할 수 있습니다.</li></ul><p>이제 GraphQL 객체 타입이 무엇인지 배웠으며 GraphQL 타입 언어의 기본적인 것을 읽을 수 있습니다.</p><h3><a class="anchor" name="arguments"></a>Arguments <a class="hash-link" href="#arguments">#</a></h3><p>GraphQL 객체 타입의 모든 필드는 0개 이상의 인수를 가질 수 있습니다(예: 아래 <code>length</code> 필드).</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Starship <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="punctuation">!</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">length</span><span class="argDefs"><span class="punctuation">(</span><span class="attr-name">unit</span><span class="punctuation">:</span> <span class="type-name">LengthUnit</span> <span class="operator">=</span> METER<span class="punctuation">)</span></span><span class="punctuation">:</span> <span class="type-name">Float</span>
<span class="punctuation">}</span></span></span></pre><p>모든 인수에는 이름이 있습니다. 함수가 정렬된 인수 목록을 가져오는 JavaScript 및 Python과 같은 언어와 달리 GraphQL의 모든 인수는 특별한 이름으로 전달됩니다. 이 경우, <code>length</code> 필드는 하나의 정의 된 인수 <code>unit</code> 을 가집니다.</p><p>인수는 필수 또는 선택적일 수 있습니다. 인수가 선택적인 경우 <em>기본값</em> 을 정의 할 수 있습니다. -  <code>unit</code> 인수가 전달되지 않으면 기본적으로 <code>METER</code> 로 설정됩니다.</p><h3><a class="anchor" name="the-query-and-mutation-types"></a>The Query and Mutation types <a class="hash-link" href="#the-query-and-mutation-types">#</a></h3><p>스키마의 대부분의 타입은 일반 객체 유형일 뿐이지만 스키마 내에서는 특수한 두 가지 타입이 있습니다.</p><pre class="prism language-graphql"><span class="schema-def"><span class="keyword">schema</span> <span class="punctuation">{</span>
  <span class="keyword">query</span><span class="punctuation">:</span> <span class="type-name">Query</span>
  <span class="keyword">mutation</span><span class="punctuation">:</span> <span class="type-name">Mutation</span>
<span class="punctuation">}</span></span></pre><p>모든 GraphQL 서비스는 <code>query</code> 타입을 가지며 <code>mutation</code> 타입은 가질 수도 있고 가지지 않을 수도 있습니다. 이러한 타입은 일반 객체 타입과 동일하지만 모든 GraphQL 쿼리의 <em>진입점</em> 을 정의하므로 특별합니다. 따라서 다음과 같은 쿼리를 볼 수 있습니다.</p><div id="r102"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>즉, GraphQL 서비스는 <code>hero</code> 및 <code>droid</code> 필드가 있는 <code>Query</code> 타입이 필요합니다.</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Query <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">hero</span><span class="argDefs"><span class="punctuation">(</span><span class="attr-name">episode</span><span class="punctuation">:</span> <span class="type-name">Episode</span><span class="punctuation">)</span></span><span class="punctuation">:</span> <span class="type-name">Character</span>
  <span class="attr-name">droid</span><span class="argDefs"><span class="punctuation">(</span><span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="operator">!</span><span class="punctuation">)</span></span><span class="punctuation">:</span> <span class="type-name">Droid</span>
<span class="punctuation">}</span></span></span></pre><p>뮤테이션은 비슷한 방식으로 작동합니다. 즉, <code>Mutation</code> 타입의 필드를 정의하면 쿼리에서 호출 할 수있는 루트 뮤테이션 필드로 사용할 수 있습니다.</p><p>스키마에 대한 <code>진입점</code> 이라는 특수한 상태 이외의 다른 쿼리 타입과 뮤테이션 타입은 다른 GraphQL 객체 타입과 동일하며 해당 필드는 정확히 동일한 방식으로 작동한다는 점을 기억해야합니다.</p><h3><a class="anchor" name="scalar-types"></a>Scalar types <a class="hash-link" href="#scalar-types">#</a></h3><p>GraphQL 객체 타입은 이름과 필드를 가지고 있지만, 어느 시점에서 이 필드는 일부 구체적인 데이터로 해석되어야합니다. 이것이 스칼라 타입이 필요한 이유입니다. 즉, 쿼리의 끝을 나타냅니다.</p><p>다음 쿼리에서 <code>name</code> 과 <code>appearIn</code> 은 스칼라 타입으로 해석될 것입니다.</p><div id="r103"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>필드에 하위 필드가 없기 때문에 이 사실을 알 수 있습니다. 이 필드는 쿼리의 끝부분입니다.</p><p>GraphQL에는 기본 스칼라 타입들이 기본 제공됩니다.</p><ul><li><code>Int</code>: 부호가 있는 32비트 정수.</li><li><code>Float</code>: 부호가 있는 부동소수점 값.</li><li><code>String</code>: UTF-8 문자열.</li><li><code>Boolean</code>: <code>true</code> 또는 <code>false</code>.</li><li><code>ID</code>: ID 스칼라 타입은 객체를 다시 요청하거나 캐시의 키로써 자주 사용되는 고유 식별자를 나타냅니다. ID 타입은 String 과 같은 방법으로 직렬화됩니다. 하지만 <code>ID</code> 로 정의하는 것은 사람이 읽을 수 있도록 하는 의도가 아니라는 것을 의미합니다.</li></ul><p>대부분의 GraphQL 서비스 구현에는 맞춤 스칼라 타입을 지정하는 방법이 있습니다. 예를 들면 <code>Date</code> 타입을 정의 할 수 있습니다.</p><pre class="prism language-graphql"><span class="keyword">scalar</span> Date</pre><p>해당 타입을 직렬화, 역 직렬화 및 유효성 검사를 수행하는 방법을 정의하는 것을 구현할 수 있습니다. 예를 들어, <code>Date</code> 타입을 항상 정수형 타임스탬프로 직렬화해야 한다는 것을 지정할 수 있습니다. 그리고 클라이언트는 모든 날짜 필드에 대해 그 타입을 기대해야 합니다.</p><h3><a class="anchor" name="enumeration-types"></a>Enumeration types <a class="hash-link" href="#enumeration-types">#</a></h3><p><em>Enums</em> 라고도 하는 열거 타입은 허용되는 특정 값들로 제한되는 특별한 종류의 스칼라입니다. 이를 통해 다음을 수행할 수 있습니다.</p><ol><li>이 타입의 인수가 허용된 값 중 하나임을 검증합니다.</li><li>필드가 항상 값의 유한 집합 중 하나가 될 것임을 타입 시스템을 통해 의사 소통합니다.</li></ol><p>GraphQL 스키마 언어에서 열거형 정의가 어떻게 생겼는지 봅시다.</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">enum</span> Episode <span class="fields"><span class="punctuation">{</span>
  NEWHOPE
  EMPIRE
  JEDI
<span class="punctuation">}</span></span></span></pre><p>즉, 스키마에서 <code>Episode</code> 타입을 사용할 때마다 정확히 <code>NEWHOPE</code>, <code>EMPIRE</code>, <code>JEDI</code> 중 하나 일 것으로 예상할 수 있습니다.</p><p>다양한 언어로 작성된 GraphQL 서비스 구현은 열거형을 처리 할 수 있는 언어별 고유한 방법을 갖습니다. enum을 일급으로 지원하는 언어에서는 구현시 이를 활용할 수 있습니다. 열거형 지원이 없는 JavaScript와 같은 언어에서 이러한 값은 내부적으로 정수 집합에 매핑 될 수 있습니다. 그러나 이러한 세부 정보는 클라이언트로 보여지지 않으며 열거형 값의 문자열 이름에 관해서만 작동 할 수 있습니다.</p><h3><a class="anchor" name="lists-and-non-null"></a>Lists and Non-Null <a class="hash-link" href="#lists-and-non-null">#</a></h3><p>객체 타입, 스칼라 및 열거형은 GraphQL에서 정의 할 수 있는 유일한 타입입니다. 하지만 스키마의 다른 부분이나 쿼리 변수 선언에서 타입을 사용하면 해당 값의 유효성 검사에 영향을 주는 추가 <em>타입 수정자</em> 를 적용 할 수 있습니다. 예제를 살펴 보겠습니다.</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Character <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span><span class="punctuation">!</span>
<span class="punctuation">}</span></span></span></pre><p>여기서 <code>String</code> 타입을 사용하고 타입 이름 뒤에 느낌표 <code>!</code> 를 추가하여 <em>Non-Null</em> 로 표시합니다. 즉, 서버는 항상이 필드에 대해 null이 아닌 값을 반환 할 것으로 예상하고, 실제로 GraphQL 실행 오류를 발생시키는 null 값을 얻으면 클라이언트에게 무언가 잘못되었음을 알립니다.</p><p>Non-Null 타입 수정자는 필드에 대한 인수를 정의 할 때도 사용할 수 있습니다. 이는 GraphQL 서버가 GraphQL 문자열이나 변수에 상관없이 null 값이 해당 인수로 전달되는 경우 유효성 검사 오류를 반환하게합니다.</p><div id="r104"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="389438257"><div class="hasVariables" data-reactid="2"><div class="query-editor" data-reactid="3"></div><div class="variable-editor" data-reactid="4"></div></div><div class="result-window" data-reactid="5"></div></div></div><p>리스트는 비슷한 방식으로 작동합니다. 타입 수정자를 사용하여 타입을 <code>List</code> 로 표시 할 수 있습니다. 이 필드는 해당 타입의 배열을 반환합니다. 스키마 언어에서, 타입을 대괄호 <code>[]</code> 로 묶는 것으로 표현됩니다. 유효성 검사 단계에서 해당 값에 대한 배열이 필요한 인수에 대해서도 동일하게 작동합니다.</p><p>Non-Null 및 List 수정자를 결합 할 수도 있습니다. 예를 들면 Null이 아닌 문자열 목록을 가질 수 있습니다.</p><pre class="prism language-graphql"><span class="attr-name">myField</span><span class="punctuation">:</span> <span class="punctuation">[</span>String<span class="operator">!</span><span class="punctuation">]</span></pre><p>즉, <em>list</em> 자체는 null 일 수 있지만 null 멤버는 가질 수 없습니다. 예를 들면, JSON에서</p><pre class="prism language-js">myField<span class="punctuation">:</span> <span class="keyword">null</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&#x27;a&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;b&#x27;</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&#x27;a&#x27;</span><span class="punctuation">,</span> <span class="keyword">null</span><span class="punctuation">,</span> <span class="string">&#x27;b&#x27;</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// error</span></pre><p>Null이 아닌 문자열 목록을 정의했다고 가정해 보겠습니다.</p><pre class="prism language-graphql"><span class="attr-name">myField</span><span class="punctuation">:</span> <span class="punctuation">[</span>String<span class="punctuation">]</span><span class="operator">!</span></pre><p>목록 자체는 null 일 수 없지만 null 값을 포함 할 수 있습니다.</p><pre class="prism language-js">myField<span class="punctuation">:</span> <span class="keyword">null</span> <span spellcheck="true" class="comment">// error</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&#x27;a&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;b&#x27;</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&#x27;a&#x27;</span><span class="punctuation">,</span> <span class="keyword">null</span><span class="punctuation">,</span> <span class="string">&#x27;b&#x27;</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span></pre><p>필요에 따라 여러개의 Null 및 List 수정자를 임의로 중첩 할 수 있습니다.</p><h3><a class="anchor" name="interfaces"></a>Interfaces <a class="hash-link" href="#interfaces">#</a></h3><p>여러 타입 시스템과 마찬가지로 GraphQL도 인터페이스를 지원합니다. <em>인터페이스</em> 는 인터페이스를 구현하기 위해 타입이 포함해야하는 특정 필드 집합을 포함하는 추상 타입입니다.</p><p>예를 들면, Star Wars 3부작의 모든 등장인물을 나타내는 <code>Character</code> 인터페이스를 가질 수 있습니다.</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">interface</span> Character <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="punctuation">!</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">friends</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Character</span><span class="punctuation">]</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span><span class="punctuation">!</span>
<span class="punctuation">}</span></span></span></pre><p>이것은 <code>Character</code> 를 <em>구현한</em> 모든 타입은 이러한 인자와 리턴 타입을 가진 정확한 필드를 가져야 한다는 것을 의미합니다.</p><p>다음은 <code>Character</code> 를 구현한 몇 가지 타입 예제입니다.</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Human <span class="keyword">implements</span> Character <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="punctuation">!</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">friends</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Character</span><span class="punctuation">]</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span><span class="punctuation">!</span>
  <span class="attr-name">starships</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Starship</span><span class="punctuation">]</span>
  <span class="attr-name">totalCredits</span><span class="punctuation">:</span> <span class="type-name">Int</span>
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">type</span> Droid <span class="keyword">implements</span> Character <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="punctuation">!</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">friends</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Character</span><span class="punctuation">]</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span><span class="punctuation">!</span>
  <span class="attr-name">primaryFunction</span><span class="punctuation">:</span> <span class="type-name">String</span>
<span class="punctuation">}</span></span></span></pre><p>이 두 타입 모두 <code>Character</code> 인터페이스의 모든 필드를 가지고 있음을 알 수 있습니다. 또한 특정 타입의 문자에 특정한 추가 필드 <code>totalCredits</code>,<code>starships</code> 및 <code>primaryFunction</code> 을 가질수도 있습니다.</p><p>인터페이스는 객체 또는 객체집합을 반환하려는 경우에 유용하지만 여러 다른 타입이 있을 수 있습니다.</p><p>예를 들면, 다음 쿼리는 오류를 반환합니다.</p><div id="r105"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="389438257"><div class="hasVariables" data-reactid="2"><div class="query-editor" data-reactid="3"></div><div class="variable-editor" data-reactid="4"></div></div><div class="result-window" data-reactid="5"></div></div></div><p><code>hero</code> 필드는 <code>Character</code> 타입을 반환하는데, <code>episode</code> 인수에 따라 <code>Human</code> 또는 <code>Droid</code> 중 하나 일 수 있습니다. 위 쿼리는 <code>primary</code> 함수를 포함하지 않는 <code>Character</code> 인터페이스 상에 존재하는 필드만을 요청할 수 있습니다.</p><p>특정 객체 타입의 필드를 요청하려면 인라인 프래그먼트을 사용해야합니다.</p><div id="r106"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="389438257"><div class="hasVariables" data-reactid="2"><div class="query-editor" data-reactid="3"></div><div class="variable-editor" data-reactid="4"></div></div><div class="result-window" data-reactid="5"></div></div></div><p>이에 대한 자세한 내용은 쿼리 가이드의 <a href="/learn/queries/#inline-fragments">인라인 프래그먼트</a> 장을 참조하세요.</p><h3><a class="anchor" name="union-types"></a>Union types <a class="hash-link" href="#union-types">#</a></h3><p>유니언 타입은 인터페이스와 매우 유사하지만 타입 간에 공통 필드를 지정하지 않습니다.</p><pre class="prism language-graphql"><span class="union-def"><span class="keyword">union</span> SearchResult <span class="punctuation">=</span> <span class="type-name">Human</span> <span class="punctuation">|</span> <span class="type-name">Droid</span> <span class="punctuation">|</span> <span class="type-name">Starship</span></span></pre><p>스키마에서 <code>SearchResult</code> 타입을 반환 할 때마다, <code>Human</code>, <code>Droid</code> 또는 <code>Starship</code> 을 얻을 수 있습니다. 유니온 타입의 멤버는 구체적인 객체 타입일 필요가 있습니다. 인터페이스 또는 다른 유니온 타입에서 유니온 타입을 작성할 수 없습니다.</p><p>이 경우, <code>SearchResult</code> 유니언 타입을 반환하는 필드를 쿼리하면, 어떤 필드라도 쿼리 할 수 있는 조건부 프래그먼트를 사용해야합니다.</p><div id="r107"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><h3><a class="anchor" name="input-types"></a>Input types <a class="hash-link" href="#input-types">#</a></h3><p>지금까지는 열거형이나 문자열과 같은 스칼라 값을 인수로 필드에 전달하는 방법에 대해서만 설명했습니다. 하지만 복잡한 객체도 쉽게 전달할 수 있습니다. 이것은 뮤테이션에서 특히 유용합니다. 여기서 뮤테이션은 생성될 전체 객체를 전달하고자 할 수 있습니다. GraphQL 스키마 언어에서 입력 타입은 일반 객체 타입과 정확히 같지만 <code>type</code> 대신 <code>input</code> 을 사용합니다.</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">input</span> ReviewInput <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">stars</span><span class="punctuation">:</span> <span class="type-name">Int</span><span class="punctuation">!</span>
  <span class="attr-name">commentary</span><span class="punctuation">:</span> <span class="type-name">String</span>
<span class="punctuation">}</span></span></span></pre><p>다음은 뮤테이션에서 입력 객체 타입을 사용하는 방법입니다.</p><div id="r108"><div class="miniGraphiQL" data-reactroot="" data-reactid="1" data-react-checksum="389438257"><div class="hasVariables" data-reactid="2"><div class="query-editor" data-reactid="3"></div><div class="variable-editor" data-reactid="4"></div></div><div class="result-window" data-reactid="5"></div></div></div><p>입력 객체 타입의 입력란은 입력 객체 타입을 참조 할 수 있지만 입력 및 출력 타입을 스키마에 혼합 할 수는 없습니다. 입력 객체 타입도 필드에 인수를 가질 수 없습니다.</p></div><a class="read-next" href="/learn/validation"><span class="read-next-continue">계속 읽기 →</span><span class="read-next-title">검사</span></a></div><div class="nav-docs"><div><h3>배우기</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/">소개</a></li></ul></div><div><h3>Learn</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/queries/">쿼리 &amp; 뮤테이션</a><ul><li><a href="/learn/queries/#fields">Fields</a></li><li><a href="/learn/queries/#arguments">Arguments</a></li><li><a href="/learn/queries/#aliases">Aliases</a></li><li><a href="/learn/queries/#fragments">Fragments</a></li><li><a href="/learn/queries/#operation-name">Operation Name</a></li><li><a href="/learn/queries/#variables">Variables</a></li><li><a href="/learn/queries/#directives">Directives</a></li><li><a href="/learn/queries/#mutations">Mutations</a></li><li><a href="/learn/queries/#inline-fragments">Inline Fragments</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/schema/">스키마 &amp; 타입</a><ul><li><a href="/learn/schema/#type-system">Type System</a></li><li><a href="/learn/schema/#type-language">Type Language</a></li><li><a href="/learn/schema/#object-types-and-fields">Object Types and Fields</a></li><li><a href="/learn/schema/#arguments">Arguments</a></li><li><a href="/learn/schema/#the-query-and-mutation-types">The Query and Mutation Types</a></li><li><a href="/learn/schema/#scalar-types">Scalar Types</a></li><li><a href="/learn/schema/#enumeration-types">Enumeration Types</a></li><li><a href="/learn/schema/#lists-and-non-null">Lists and Non-Null</a></li><li><a href="/learn/schema/#interfaces">Interfaces</a></li><li><a href="/learn/schema/#union-types">Union Types</a></li><li><a href="/learn/schema/#input-types">Input Types</a></li></ul></li><li><a style="margin-left:0;" class="active" href="/learn/validation/">검사</a></li><li><a style="margin-left:0;" class="active" href="/learn/execution/">실행</a></li><li><a style="margin-left:0;" class="active" href="/learn/introspection/">복원</a></li></ul></div><div><h3>Best Practices</h3><ul><li><a style="margin-left:0;" class="active" href="/learn/best-practices/">소개</a></li><li><a style="margin-left:0;" class="active" href="/learn/thinking-in-graphs/">그래프로 생각하기</a></li><li><a style="margin-left:0;" class="active" href="/learn/serving-over-http/">HTTP를 통한 서빙</a></li><li><a style="margin-left:0;" class="active" href="/learn/authorization/">인증</a></li><li><a style="margin-left:0;" class="active" href="/learn/pagination/">페이지네이션</a></li><li><a style="margin-left:0;" class="active" href="/learn/caching/">캐싱</a></li></ul></div></div></div></section><footer><section class="sitemap"><a href="/" class="nav-home"></a><div><h5><a href="/learn/">배우기</a></h5><a href="/learn/">소개</a><a href="/learn/queries/">쿼리 언어</a><a href="/learn/schema/">타입 시스템</a><a href="/learn/execution/">실행</a><a href="/learn/best-practices/">모범 사례</a></div><div><h5><a href="/code">코드</a></h5><a href="/code/#server-libraries">서버</a><a href="/code/#graphql-clients">클라이언트</a><a href="/code/#tools">도구</a></div><div><h5><a href="/community">커뮤니티</a></h5><a href="/community/upcoming-events/">이벤트</a><a href="http://stackoverflow.com/questions/tagged/graphql" target="_blank" rel="noopener noreferrer">스택 오버플로우</a><a href="https://www.facebook.com/groups/graphql.community/" target="_blank" rel="noopener noreferrer">페이스북 그룹</a><a href="https://twitter.com/GraphQL" target="_blank" rel="noopener noreferrer">트위터</a></div><div><h5>기타</h5><a href="/blog">GraphQL 팀 블로그</a><a href="http://facebook.github.io/graphql/" target="_blank" rel="noopener noreferrer">명세</a><a href="https://github.com/graphql" target="_blank" rel="noopener noreferrer">깃허브</a><a href="https://github.com/graphql/graphql.github.io/edit/source/site/learn/Learn-Schema.md" target="_blank" rel="noopener noreferrer">이 페이지 수정 ✎</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" rel="noopener noreferrer" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright ©<span><script>document.write(new Date().getFullYear())</script> </span><noscript>2017 </noscript>Facebook Inc. The contents of this page are licensed BSD-3-Clause.</section></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
        docsearch({
          apiKey: 'd103541f3e6041148aade2e746ed4d61',
          indexName: 'graphql',
          inputSelector: '#algolia-search-input'
        });
      </script><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44373548-16', 'auto');
ga('send', 'pageview');
      </script><script src="/vendor/react-15.0.1.min.js"></script><script src="/vendor/react-dom-15.0.1.min.js"></script><script src="index.html.c79490163c16d7ea974c.js"></script></body></html>
